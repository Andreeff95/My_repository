Hello world! Начинаем наше знакомство с контролем версий.
# GIT. Руководство пользователя.
## Краткая шпаргалка по командам GIT'а:

* git init - *инициализует локальный репозиторий*
* git add - *начинает отслеживать файл проекта*
* git commit -m "<комментарий>" - *создает commit* 
* git log - *выводит список изменений в файле. Для выхода из лога нажмите "q" (очевидно, что "q" - это явная отсылка на "Ку!" из фильма "Кин-дза-дза")*
* git branch - *выводит список всех веток коммитов*
* git branch new_branch_name - *создает новую ветку коммитов*


**Обязательно нужно указать комментарий в кавычках!**

Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

1. Создан новый функционал

2. Добавлен новый блок на верстке

3. Исправлены ошибки по коду

4. Вы завершили рабочий день и хотите сохранить код

## Коммиты в GIT

_нижеследующая информация любезно "предоставлена" сайтом learngitbranching.js.org_

Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше

Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит в набор изменений или «дельту» между текущей версией и предыдущей.

Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом!

Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта. Коммиты очень легки, так что переключение между ними происходит предельно быстро!

Посмотрим, как это выглядит на практике. Ниже расположена визуализация небольшого git репозитория. Сейчас в нём два коммита: первый, исходный коммит С0 и один коммит С1 после него, содержащий изменения.

![](/manual_images/1-01.png)

    git commit

![](/manual_images/1-02.png)

Отлично. Мы только что внесли изменения в репозиторий и сохранили их как коммит. У коммита, который мы только что сделали, есть родитель, С1, который указывает на предыдущий коммит.


# Ветвление в Git
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру

    делай ветки сразу, делай ветки часто
Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.

Чуть позже мы попробуем использовать ветки и коммиты, и вы увидите, как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущего коммита и всех его "родителей".

Посмотрим, что такое ветки на практике

Создадим здесь новую ветку с именем newImage.
![](/manual_images/2-01.png)
 
    git branch newImage

Вот и всё, ребята! Ветка newImage теперь указывает на коммит C1. 

![](/manual_images/2-02.png)

Теперь попробуем сделать некоторые изменения в этой ветке.

    git commit

![](/manual_images/2-03.png)

О нет! Ветка main сдвинулась, тогда как ветка newImage - нет! Всё из-за того, что мы не переключились на новую ветку, а остались в старой, о чём говорит звёздочка около ветки main.

Сообщим Git, что хотим выбрать ветку

    git checkout [name]

Эта команда перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения

    git checkout newImage; git commit   

![](/manual_images/2-04.png)

Вот так! Наши изменения записаны уже в новую ветку

Совет - ты можешь создать новую ветку и переключиться на неё с помощью одной команды: git checkout -b [yourbranchname].

# Ветки и слияния
Мы уже знаем, как создавать ветки и коммитить наши изменения. Теперь надо понять, как объединять изменения из двух разных веток. Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими.

Первый способ объединения изменений, который мы рассмотрим - это **git merge** - слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами.

На схеме всё проще и понятнее.

![](/manual_images/3-01.png)

Вот у нас две ветки, каждая содержит по одному уникальному коммиту. Это означает, что ни одна из веток не содержит полный набор "работ", выполненных в этом репозитории. Можно исправить эту ситуацию, выполнив слияние.

Мы сделаем **merge** ветки **bugFix** в ветку **main**.

    git merge bugFix

![](/manual_images/3-02.png)

Что мы видим? Во-первых, ветка **main** теперь указывает на коммит, у которого два родителя. Если проследовать по стрелкам от этого коммита, вы пройдёте через каждый коммит в дереве прямиком к началу. Это означает, что теперь в ветке **main** содержатся все изменения репозитория.

Во-вторых, обрати внимание, как изменились цвета коммитов. Мы ввели цветовую дифференциацию, чтобы помочь пониманию. У каждой ветки — свой цвет. Каждый коммит становится того цвета, какого его ветка. Если в нём изменения сразу двух веток - он становится цветом, смешанным из цветов родительских веток.

И вот мы видим, что цвет ветки **main** подмешан к каждому коммиту, а ветки **bugFix** - нет. Это можно поправить.

Смерджим ветку **main** в ветку **bugFix**.

    git checkout bugFix; git merge main

![](/manual_images/3-03.png)

Так как ветка **bugFix** была предшественницей **main**, Git не делал ничего, только сдвинул **bugFix** на тот же коммит, где находится **main**

Теперь все коммиты одного цвета, что означает, что каждая ветка содержит все изменения репозитория! Поздравляем!

# Git Rebase

Второй способ объединения изменений в ветках - это *rebasing*. При ребейзе Git по сути копирует набор коммитов и переносит их в другое место.

Несмотря на то, что это звучит достаточно непонятно, преимущество **rebase** в том, что c его помощью можно делать чистые и красивые линейные последовательности коммитов. История коммитов будет чище, если вы применяете **rebase**.

![](/manual_images/4-01.png)

У нас здесь снова две ветки. Обратите внимание, что выбрана ветка **bugFix** (отмечена звёздочкой)

Хочется сдвинуть наши изменения из **bugFix** прямо на вершину ветки **main**. Благодаря этому всё будет выглядеть, как будто эти изменения делались последовательно, хотя на самом деле - параллельно.

Применим **git rebase**.

    git rebase main

![](/manual_images/4-02.png)

Теперь изменения из **bugFix** находятся в конце ветки **main** и являют собой линейную последовательность коммитов.

Обрати внимание, что коммит С3 до сих пор существует где-то, а С3' - это его "копия" в ветке **main**

Единственная проблема - ветка **main** не обновлена до последних изменений. Это легко исправить.

![](/manual_images/4-03.png)

Вот мы выбрали ветку **main**. Вперёд - сделаем rebase на **bugFix**.

    git rebase bugFix

![](/manual_images/4-04.png)

Вуаля! Так как **main** был предком **bugFix**, git просто сдвинул ссылку на **main** вперёд.

# Прогулка по Git

Прежде чем перейти к более продвинутым фичам Git, важно понять различные способы перемещения по дереву коммитов вашего проекта.

Как только вы научитесь свободно передвигаться по дереву коммитов, ваши возможности в Git приумножатся.

В первую очередь, поговорим о "HEAD". **HEAD** - это символическое имя текущего выбранного коммита — это, по сути, тот коммит, над которым мы в данный момент работаем.

HEAD всегда указывает на последний коммит из вашего локального дерева. Большинство команд Git, изменяющих рабочее дерево, начнут с изменения HEAD.

Обычно HEAD указывает на имя ветки (например, **bugFix**). Когда вы делаете коммит, статус ветки **bugFix** меняется и это изменение видно через HEAD. Посмотрим, как это работает.

![](/manual_images/5-01.png)

Обратите внимание на то, где находится HEAD до и после коммита.

    git checkout C1; git checkout main; git commit; git checkout C2

![](/manual_images/5-02.png)
![](/manual_images/5-01.png)
![](/manual_images/5-03.png)
![](/manual_images/5-05.png)

Вот! HEAD всё это время скрывался за веткой **main**.

**Detaching HEAD**

Отделение (detaching) HEAD означает лишь присвоение его не ветке, а конкретному коммиту. Посмотрим, что было до отделения:

*HEAD -> main -> C1*

![](/manual_images/5-01.png)

    git checkout C1

![](/manual_images/5-02.png)

А вот что получилось теперь

*HEAD -> C1*

# Относительные ссылки

Передвигаться по дереву Git при помощи указания хешей коммитов немного неудобно. В реальной ситуации у вас вряд ли будет красивая визуализация дерева в терминале, так что придётся каждый раз использовать **git log**, чтобы найти хеш нужного коммита

Более того, хеши в реальном репозитории Git намного более длинные. Например, хеш для коммита, который приведён в предыдущем уровне - **fed2da64c0efc5293610bdd892f82a58e8cbc5d8**. Не очень просто для произношения.

Хорошая новость в том, что Git достаточно умён в работе с хешами. Ему нужны лишь первые несколько символов для того, чтобы идентифицировать конкретный коммит. Так что можно написать просто **fed2** вместо колбасы выше.

С относительными ссылками можно начать с какого-либо удобного места (например, с ветки **bugFix** или от HEAD) и двигаться от него

Относительные ссылки - мощный инструмент, но мы покажем два простых способа использования:

* Перемещение на один коммит назад **^**
* Перемещение на несколько коммитов назад **~<*num*>**

Для начала рассмотрим оператор каретки (^). 

![](/manual_images/6-01.png)

Когда мы добавляем его к имени ссылки, Git воспринимает это как указание найти родителя указанного коммита.

Так что **main^** означает "первый родитель ветки **main**".

**main^^** означает прародитель (родитель родителя) **main**

Давайте переключимся на коммит выше **main**

    git checkout main^

![](/manual_images/6-02.png)

Готово. Сильно проще, чем поиск и указание хеша.

Можно также использовать **HEAD** как относительную ссылку. Попробуем пройти несколько раз назад по дереву коммитов ниже:

![](/manual_images/6-03.png)

    git checkout C3; git checkout HEAD^; git checkout HEAD^; git checkout HEAD^

![](/manual_images/6-04.png)
![](/manual_images/6-05.png)
![](/manual_images/6-06.png)
![](/manual_images/6-07.png)

Таким образом мы можем путешествовать во времени при помощи **HEAD^**

**Оператор "~"**

Предположим, нужно переместиться на много шагов назад по дереву. Было бы неудобно печатать **^** несколько раз (или несколько десятков раз), так что Git поддерживает также оператор тильда (~).

К тильде (опционально) можно добавить количество родительских коммитов, через которые нужно пройти. Посмотрим, как это работает.

![](/manual_images/6-08.png)

Укажем после **~** число коммитов, через которые надо пройти.

    git checkout HEAD~4

![](/manual_images/6-09.png)

Очевидно, относительные ссылки прекрасны.

**Перемещение ветки (branch forcing)**

Теперь мы разбираемся в относительных ссылках, так что можно реально использовать их для дела.

Одна из наиболее распространённых целей, для которых используются относительные ссылки - это перемещение веток. Можно напрямую прикрепить ветку к коммиту при помощи опции **-f**. Например, команда:

    git branch -f main HEAD~3

Переместит (принудительно) ветку **main** на три родителя назад от **HEAD**.

Посмотрим, как работает эта команда

![](/manual_images/6-10.png)

    git branch -f main HEAD~3

![](/manual_images/6-11.png)

Относительная ссылка дала нам возможность просто сослаться на **C1**, а branch forcing (**-f**) позволил быстро переместить указатель ветки на этот коммит.

# Отмена изменений в Git

Есть много путей для отмены изменений в Git. Так же как и коммит, отмена изменений в Git возможна и на низком уровне (добавление в коммит отдельных файлов и наборов строк), и на высоком (как изменения реально отменяются). Сейчас сфокусируемся на высокоуровневой части.

Есть два основных способа отмены изменений в Git: первый - это **git reset**, а второй - **git revert**. Попробуем оба на следующем шаге.

**Git Reset**

**git reset** отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; **git reset** перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.

Посмотрим, как это работает:

![](/manual_images/7-01.png)

    git reset HEAD~1

![](/manual_images/7-02.png)

Неплохо! Git просто перенёс ссылку на **main** обратно на коммит **C1**. Теперь наш локальный репозиторий в состоянии, как будто **C2** никогда не существовал.

**Git Revert**

Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.

Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать **git revert**. Посмотрим, как это работает:

![](/manual_images/7-03.png)

    git revert HEAD

![](/manual_images/7-04.png)

Забавно, появился новый коммит. Дело в том, что новый коммит **C2'** просто содержит изменения, полностью противоположные тем, что сделаны в коммите **C2**.

После **revert** можно сделать **push** и поделиться изменениями с остальными.

# Работа с удаленными репозиторями

Удаленный (иногда говорят "внешний") репозиторий – это версии вашего проекта, сохраненные на удаленном сервере. Доступ к репозиторию на таком сервере может осуществляться по интернету или по локальной сети.
Удаленный репозиторий – полноценный репозиторий, ничем не отличающийся от локального. У удаленного репозитория есть собственные ветки, собственный указатель **HEAD**, своя история коммитов и так далее.

Если мы подключим удаленный репозиторий к своему локальному, то у нас появятся копии всех ссылочных объектов удаленного репозитория. То есть, например, у удаленного репозитория есть ветка **main**, а у нас будет копия этой ветки – **origin/main**. Все такие ссылочные объекты (указатели, ветки и теги) удаленного репозитория хранятся почти там же, где и у локального – в директории **.git/refs/remotes/<имя_удаленного_репозитория>**.

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду **git remote**. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум **origin** — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование. Вы можете также указать ключ **-v**, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию.

**Отправка изменений в удалённый репозиторий (Push)**

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: **git push <remote-name> <branch-name>**. Чтобы отправить вашу ветку **master** на сервер **origin** (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

    $ git push origin master

А еще лучше: 

    git push -u origin main 

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду **push**. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду **push**, а после него выполнить команду **push** попытаетесь вы, то ваш **push** точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить **push**. 


## Бонус: разметка языка Markdown
**Жирный текст - использовать две зведочки:** ** 

*Курсивный текст - использовать одну звездочу:* *

Зачеркнутый текст - использовать ~~одну~~ две! тильды: ~~ (это же тильда?)

Для выделения заголовка - использовать # и ## в начале строки

    Вложенный список создается отступом
1. Нумерованный список обозначается цифрами (1. 2. 3. )
* Ненумерованный список - * в начале строки

Для вставки изображения нужно указать путь в виде **![]**(**/path/file.png**)
 