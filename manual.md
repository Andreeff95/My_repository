Hello world! Начинаем наше знакомство с контролем версий.
# GIT. Руководство пользователя.
## Краткая шпаргалка по командам GIT'а:

* git init - *инициализует локальный репозиторий*
* git add - *начинает отслеживать файл проекта*
* git commit -m "<комментарий>" - *создает commit* 
* git log - *выводит список изменений в файле. Для выхода из лога нажмите "q" (очевидно, что "q" - это явная отсылка на "Ку!" из фильма "Кин-дза-дза")*
* git branch - *выводит список всех веток коммитов*
* git branch new_branch_name - *создает новую ветку коммитов*


**Обязательно нужно указать комментарий в кавычках!**

Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

1. Создан новый функционал

2. Добавлен новый блок на верстке

3. Исправлены ошибки по коду

4. Вы завершили рабочий день и хотите сохранить код

## Коммиты в GIT

_нижеследующая информация любезно "предоставлена" сайтом learngitbranching.js.org_

Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше

Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит в набор изменений или «дельту» между текущей версией и предыдущей.

Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом!

Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта. Коммиты очень легки, так что переключение между ними происходит предельно быстро!

Посмотрим, как это выглядит на практике. Ниже расположена визуализация небольшого git репозитория. Сейчас в нём два коммита: первый, исходный коммит С0 и один коммит С1 после него, содержащий изменения.
*<Здесь и далее будут картинки>*
Отлично. Мы только что внесли изменения в репозиторий и сохранили их как коммит. У коммита, который мы только что сделали, есть родитель, С1, который указывает на предыдущий коммит.
*<картинка>*

# Ветвление в Git
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру

    делай ветки сразу, делай ветки часто
Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.

Чуть позже мы попробуем использовать ветки и коммиты, и вы увидите, как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущего коммита и всех его "родителей".

Посмотрим, что такое ветки на практике

Создадим здесь новую ветку с именем newImage.
*<картинка1>*
 
    git branch newImage

Вот и всё, ребята! Ветка newImage теперь указывает на коммит C1. *<картинка2>*

Теперь попробуем сделать некоторые изменения в этой ветке. *<картинка3>*

    git commit

*<картинка4>* О нет! Ветка main сдвинулась, тогда как ветка newImage - нет! Всё из-за того, что мы не переключились на новую ветку, а остались в старой, о чём говорит звёздочка около ветки main.

Сообщим Git, что хотим выбрать ветку

    git checkout [name]

Эта команда перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения

    git checkout newImage; git commit   

*<картинка5>*

Вот так! Наши изменения записаны уже в новую ветку

Совет - ты можешь создать новую ветку и переключиться на неё с помощью одной команды: git checkout -b [yourbranchname].

# Ветки и слияния
ОМы уже знаем, как создавать ветки и коммитить наши изменения. Теперь надо понять, как объединять изменения из двух разных веток. Очень удобно создать ветку, сделать свою часть работы в ней и потом объединить изменения из своей ветки с общими.

Первый способ объединения изменений, который мы рассмотрим - это git merge - слияние или просто мердж. Слияния в Git создают особый вид коммита, который имеет сразу двух родителей. Коммит с двумя родителями обычно означает, что мы хотим объединить изменения из одного коммита с другим коммитом и всеми их родительскими коммитами.

На схеме всё проще и понятнее.

*<картинка1>*

Вот у нас две ветки, каждая содержит по одному уникальному коммиту. Это означает, что ни одна из веток не содержит полный набор "работ", выполненных в этом репозитории. Можно исправить эту ситуацию, выполнив слияние.

Мы сделаем merge ветки bugFix в ветку main.

    git merge bugFix

*<картинка2>*

Что мы видим? Во-первых, ветка main теперь указывает на коммит, у которого два родителя. Если проследовать по стрелкам от этого коммита, вы пройдёте через каждый коммит в дереве прямиком к началу. Это означает, что теперь в ветке main содержатся все изменения репозитория.

Во-вторых, обрати внимание, как изменились цвета коммитов. Мы ввели цветовую дифференциацию, чтобы помочь пониманию. У каждой ветки — свой цвет. Каждый коммит становится того цвета, какого его ветка. Если в нём изменения сразу двух веток - он становится цветом, смешанным из цветов родительских веток.

И вот мы видим, что цвет ветки main подмешан к каждому коммиту, а ветки bugFix - нет. Это можно поправить.

*<картинка3 - вполне возможно, что здесь не нужна>*
Смерджим ветку main в ветку bugFix.

    git checkout bugFix; git merge main

  *<картинка4>*  

Так как ветка bugFix была предшественницей main, Git не делал ничего, только сдвинул bugFix на тот же коммит, где находится main

Теперь все коммиты одного цвета, что означает, что каждая ветка содержит все изменения репозитория! Поздравляем!

__*Нужен еще раздел про рибейс, похже добавь*__


## Бонус: разметка языка Markdown
**Жирный текст - использовать две зведочки:** ** 

*Курсивный текст - использовать одну звездочу:* *

Зачеркнутый текст - использовать ~~одну~~ две! тильды: ~~ (это же тильда?)

Для выделения заголовка - использовать # и ## в начале строки

    Вложенный список создается отступом
1. Нумерованный список обозначается цифрами (1. 2. 3. )
* Ненумерованный список - * в начале строки




 