Hello world! Начинаем наше знакомство с контролем версий.
# GIT. Руководство пользователя.
## Краткая шпаргалка по командам GIT'а:

* git init - *инициализует локальный репозиторий*
* git add - *начинает отслеживать файл проекта*
* git commit -m "<комментарий>" - *создает commit* 
* git log - *выводит список изменений в файле. Для выхода из лога нажмите "q" (очевидно, что "q" - это явная отсылка на "Ку!" из фильма "Кин-дза-дза")*
* git branch - *выводит список всех веток коммитов*
* git branch new_branch_name - *создает новую ветку коммитов*


**Обязательно нужно указать комментарий в кавычках!**

Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

1. Создан новый функционал

2. Добавлен новый блок на верстке

3. Исправлены ошибки по коду

4. Вы завершили рабочий день и хотите сохранить код

## Коммиты в GIT

_нижеследующая информация любезно "предоставлена" сайтом learngitbranching.js.org_

Коммит в git репозитории хранит снимок всех файлов в директории. Почти как огромная копия, только лучше

Git пытается быть лёгким и быстрым насколько это только возможно, так что он не просто слепо копирует всю директорию каждый раз, а ужимает (когда это возможно) коммит в набор изменений или «дельту» между текущей версией и предыдущей.

Также Git хранит всю историю о том, когда какой коммит был сделан. Вот почему большинство коммитов имеют предков - мы указываем на предков стрелками при визуализации. Поддержка истории коммитов более чем важна для всех, кто работает над проектом!

Можно ещё долго рассказывать о коммитах, но для простоты будем считать их полными снимками проекта. Коммиты очень легки, так что переключение между ними происходит предельно быстро!

Посмотрим, как это выглядит на практике. Ниже расположена визуализация небольшого git репозитория. Сейчас в нём два коммита: первый, исходный коммит С0 и один коммит С1 после него, содержащий изменения.
*<Здесь и далее будут картинки>*
Отлично. Мы только что внесли изменения в репозиторий и сохранили их как коммит. У коммита, который мы только что сделали, есть родитель, С1, который указывает на предыдущий коммит.
*<картинка>*

# Ветвление в Git
Ветки в Git, как и коммиты, невероятно легковесны. Это просто ссылки на определённый коммит — ничего более. Вот почему многие фанаты Git повторяют мантру

    делай ветки сразу, делай ветки часто
Так как создание множества веток никак не отражается на памяти или жестком диске, удобнее и проще разбивать свою работу на много маленьких веток, чем хранить все изменения в одной огромной ветке.

Чуть позже мы попробуем использовать ветки и коммиты, и вы увидите, как две эти возможности сочетаются. Можно сказать, что созданная ветка хранит изменения текущего коммита и всех его "родителей".

Посмотрим, что такое ветки на практике

Создадим здесь новую ветку с именем newImage.
*<картинка1>*
 
    git branch newImage

Вот и всё, ребята! Ветка newImage теперь указывает на коммит C1. *<картинка2>*

Теперь попробуем сделать некоторые изменения в этой ветке. *<картинка3>*

    git commit

*<картинка4>* О нет! Ветка main сдвинулась, тогда как ветка newImage - нет! Всё из-за того, что мы не переключились на новую ветку, а остались в старой, о чём говорит звёздочка около ветки main.

Сообщим Git, что хотим выбрать ветку

    git checkout [name]

Эта команда перенесёт нас на новую ветку в момент, когда мы ещё не коммитили изменения

    git checkout newImage; git commit   

*<картинка5>*

Вот так! Наши изменения записаны уже в новую ветку

Совет - ты можешь создать новую ветку и переключиться на неё с помощью одной команды: git checkout -b [yourbranchname].



## Бонус: разметка языка Markdown
**Жирный текст - использовать две зведочки:** ** 

*Курсивный текст - использовать одну звездочу:* *

Зачеркнутый текст - использовать ~~одну~~ две! тильды: ~~ (это же тильда?)

Для выделения заголовка - использовать # и ## в начале строки

    Вложенный список создается отступом
1. Нумерованный список обозначается цифрами (1. 2. 3. )
* Ненумерованный список - * в начале строки




 